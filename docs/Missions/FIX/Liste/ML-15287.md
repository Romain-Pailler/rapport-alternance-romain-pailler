---
sidebar_label: "ML-15287 – Rechargement inutile après fermeture de modale RIB/RUM"
sidebar_position: 11
tags:
  - Bug
  - Comptabilité
---

# Suppression du rechargement de la page RIB/RUM en cas de fermeture sans action

## Contexte

Sur la page de gestion des **RIB** et **[mandats RUM](../../../glossaire/Vocab_metier.md#couple-ribrum)**, les utilisateurs peuvent réaliser différentes opérations :

- Modifier ou sauvegarder un RIB
- Désactiver un RIB ou un mandat
- Générer manuellement un [mandat SEPA](../../../glossaire/Vocab_metier.md#mandat-sepa)

Ces actions s’effectuent via des **modales de confirmation**. Toutefois, un comportement inattendu avait été observé : même lorsqu’aucune action n’était validée (fermeture de la modale sans confirmation), l’interface rechargeait systématiquement la liste des couples RIB/RUM.

## Ticket

![Screenshot du ticket Jira](/img/fix/ml_15287.png)

## Problème

Le code appelait systématiquement la méthode `reloadCouplesRibRum()`, quel que soit le choix de l’utilisateur.  
Résultat : un **rafraîchissement visuel inutile** à chaque fermeture de modale, même en cas d’annulation.  
Ça rendait la navigation moins fluide et pouvait faire perdre le fil lorsqu’on parcourait plusieurs éléments à la suite.

## Correction

J’ai revu la logique pour que **le rechargement ne s’effectue que si l’utilisateur confirme réellement l’action**.

J’ai appliqué ce comportement cohérent à toutes les actions concernées :

- Sauvegarde d’un RIB
- Désactivation d’un mandat
- Désactivation d’un RIB
- Renouvellement manuel d’un mandat SEPA

### Détail technique

Voici les principaux ajustements que j’ai apportés côté Angular :

- J’ai utilisé `filter()` de **RxJS** pour m’assurer que le traitement continue **uniquement si la réponse est positive**.
- J’ai introduit un booléen `canReload` pour bien **contrôler quand relancer le rafraîchissement**.
- Le `subscribe()` ne déclenche le `reloadCouplesRibRum()` **que si l’action a été réellement confirmée**.
- J’en ai profité pour améliorer un peu la gestion des erreurs via le `GlobalAlertService`.

### code source

#### client-comptabilite.component.ts

```ts
  /**
   * Re-charge les couples RIB / RUM du client en cours
   */
  private reloadCouplesRibRum() {
    if (this.showMandatSepa) {
      this.canCreateNewCouple = false;
      this.couplesRibRumBeforeReloading = this.couplesRibRum;
      this.couplesRibRum = [];
      this.couplesLoading = true;
      this.loadAndPopulateCouplesRibRum()
        .pipe(
          takeUntilDestroyed(this.destroyRef),
          finalize(() => (this.couplesLoading = false)),
        )
        .subscribe({
          next: (allCompletedCouplesRibRum) => {
            this.couplesRibRum = allCompletedCouplesRibRum;
            this.couplesRibRum.sort(this.sortCouplesRibRum);
          },
          complete: () => {
            this.checkAndSetCanCreateNewCouple();
          },
          error: (err) => this.globalAlertService.error(err),
        });
    }
  }
  onRIBSaveClick(coupleRibRum: InformationPrelevementViewModel) {
    let canReload: boolean = false;
    this.modalService
      .open(ConfirmModalComponent, {
        data: {
          header: $localize`Confirmer les informations du RIB ?`,
          body: $localize`Une fois que le RIB est enregistré, il ne sera plus possible de l'éditer.`,
        },
      })
      /* ancien code
      tap(() => (this.couplesLoading = true)),
        mergeMap((renewalConfirmed) => {
          if (renewalConfirmed) {
            this.completeData(coupleRibRum);
            return this.createOrUpdateInfoPrelevement(coupleRibRum.informationPrelevement);
          }
          return EMPTY;
        }), */
      .afterClosed()
      .pipe(
        takeUntilDestroyed(this.destroyRef),
        filter((result) => !!result),
        tap(() => (this.couplesLoading = true)),
        mergeMap(() => {
          this.completeData(coupleRibRum);// ajout ici
          canReload = true; // ajout ici
          return this.createOrUpdateInfoPrelevement(coupleRibRum.informationPrelevement);
        }),
      )
      .subscribe({
        next: (infoPrelevement) => {
          if (infoPrelevement) {
            coupleRibRum.informationPrelevement = infoPrelevement;
          }
        },
        complete: () => {
          //ajout du if
          if (canReload) {
            coupleRibRum.edition = false;
            this.formGroupRib.reset();
            this.reloadCouplesRibRum();
          }
        },
        error: () => {
          this.couplesLoading = false;
          coupleRibRum.edition = true;
        },
      });
  }

  /**
   * Mets à jour une information de prélèvement client si elle existe déjà, sinon la créer (à partir du RIB).
      actif: true,
    });
    this.checkAndSetCanCreateNewCouple();
  }

  downloadFile(url: string) {
    window.open(url);
  }

  desactiveMandat(idMandatSEPALoueur: number) {
    let canReload: boolean = false;
    this.modalService
      .open(ConfirmModalComponent, {
        data: {
          header: $localize`Désactiver le mandat SEPA`,
          body: $localize`Ce mandat ne sera plus actif. Un nouveau mandat sera généré à la mise en accord d’une nouvelle demande pour ce client ou un nouveau mandat pourra être généré manuellement.`,
        },
      })
      .afterClosed()
      .pipe(
        takeUntilDestroyed(this.destroyRef),
        filter((result) => !!result),
        mergeMap(() => {
          canReload = true;
          return this.clientService.desactiveMandat(idMandatSEPALoueur);
        }),
      )
      .subscribe(() => {
        if (canReload) {
          this.reloadCouplesRibRum();
        }
      });
  }

  /**
   * Désactive le RIB et le RUM du couple
   * @param couple
   */
  desactiveRibClick(couple: InformationPrelevementViewModel) {
    let canReload: boolean = false; // ajout
    this.modalService
      .open(ConfirmModalComponent, {
        data: {
          header: $localize`Êtes-vous sûr de vouloir désactiver le RIB ?`,
          body: $localize`La désactivation du RIB entrainera la désactivation du couple et de la RUM associée.`,
        },
      })
      .afterClosed()
      .pipe(
        takeUntilDestroyed(this.destroyRef),
        filter((result) => !!result), // Ne continue QUE si on confirme
        mergeMap(() => this.clientService.desactiveRibCouple(couple)), // Exécute la requête de suppression
        tap(() => {
          const cpl = this.couplesRibRum.find(
            (coupleRIBRUM) => coupleRIBRUM.informationPrelevement.id === couple.informationPrelevement.id,
          );
          if (cpl) {
            cpl.folded = true;
          }
          canReload = true;
        }),
      )
      .subscribe({
        next: () => {
          //ajout
          if (canReload) {
            this.reloadCouplesRibRum();
          }
        },
        error: (err) => this.globalAlertService.error(err),
      });
  }

  confirmAndRenewMandat(idInfoPrelevement: number | null | undefined) {
    let canReload = false;
    this.modalService
      .open(ConfirmModalComponent, {
        data: {
          header: $localize`Générer le mandat SEPA`,
          body: $localize`Le mandat actif sera désactivé et remplacé par le nouveau mandat SEPA généré`,
        },
      })
      .afterClosed()
      .pipe(
        takeUntilDestroyed(this.destroyRef),
        filter((result) => !!result),
        tap(() => {
          this.couplesLoading = true;
        }),
        mergeMap(() => this.renewMandatOn(idInfoPrelevement)),
        tap(() => {
          canReload = true;
        }),
      )
      .subscribe({
        next: () => {
          if (canReload) {
            this.reloadCouplesRibRum();
          }
        },
        error: () => {
          this.couplesLoading = false;
        },
      });
  }
```

#### client-comptabilite.spec.component.ts

```ts
 it('should not deactivate RIB (and couple) and not fold it', fakeAsync(() => {
      const coupleRibRum = {
        informationPrelevement: {
          id: 856,
          client: {} as ClientDomain,
          rib: {codeSage: ''} as RibDomain,
          allMandatsSepaLoueur: [],
        } as InformationPrelevementDomain,
        edition: true,
        folded: false,
        actif: true,
      } as InformationPrelevementViewModel;
      component.couplesRibRum.push(coupleRibRum);

      jest.spyOn(modalRefSpy, 'afterClosed').mockReturnValue(of(false));

      component.desactiveRibClick(component.couplesRibRum[0]);
      tick();

      expect(clientServiceSpy.desactiveRibCouple).not.toHaveBeenCalledWith(coupleRibRum);
      expect(
        component.couplesRibRumBeforeReloading.find(
          (cpl) => cpl.informationPrelevement.id === coupleRibRum.informationPrelevement.id,
        )?.folded,
      ).not.toBe(true);
    }));
    it('should call globalAlertService.error if desactiveRibCouple fails', fakeAsync(() => {
      const coupleRibRum = {
        informationPrelevement: {
          id: 856,
          client: {} as ClientDomain,
          rib: {codeSage: ''} as RibDomain,
          allMandatsSepaLoueur: [],
        } as InformationPrelevementDomain,
        edition: true,
        folded: false,
        actif: true,
      } as InformationPrelevementViewModel;

      component.couplesRibRum.push(coupleRibRum);

      jest.spyOn(modalRefSpy, 'afterClosed').mockReturnValue(of(true));

      jest.spyOn(clientServiceSpy, 'desactiveRibCouple').mockReturnValue(throwError(() => new Error('Erreur serveur')));

      globalAlertServiceSpy.error = jest.fn();

      component.desactiveRibClick(component.couplesRibRum[0]);
      tick();

      expect(globalAlertServiceSpy.error).toHaveBeenCalledWith(expect.any(Error));
    }));
     it('should not renew mandat', fakeAsync(() => {
      const coupleRibRum = {
        informationPrelevement: {
          id: 856,
          client: {} as ClientDomain,
          rib: {codeSage: ''} as RibDomain,
          allMandatsSepaLoueur: [],
        } as InformationPrelevementDomain,
        edition: true,
        folded: false,
        actif: true,
      } as InformationPrelevementViewModel;
      component.couplesRibRum.push(coupleRibRum);
      jest.spyOn(modalRefSpy, 'afterClosed').mockReturnValue(of(false));

      component.confirmAndRenewMandat(coupleRibRum.informationPrelevement.id);
      tick();

      expect(clientServiceSpy.renewMandatSepaClient).not.toHaveBeenCalled();
    }));

it('should not desactivate', fakeAsync(() => {
      jest.spyOn(modalRefSpy, 'afterClosed').mockReturnValue(of(false));

      component.desactiveMandat(mandatSepaActif.id);
      tick();

      expect(clientServiceSpy.desactiveMandat).not.toHaveBeenCalled();
    }));

 it('should edit and not save RIB', fakeAsync(() => {
      const infoPrelevement = {
        id: 856,
        client: {} as ClientDomain,
        rib: {codeSage: ''} as RibDomain,
        allMandatsSepaLoueur: [],
      };
      const coupleRibRum = {
        informationPrelevement: infoPrelevement as InformationPrelevementDomain,
        edition: true,
        folded: false,
        actif: true,
      } as InformationPrelevementViewModel;
      component.couplesRibRum.push(coupleRibRum);

      expect(component.couplesRibRum[0].edition).toBe(true);
      expect(component.couplesRibRum[0].folded).toBe(false);
      expect(component.couplesRibRum[0].actif).toBe(true);
      component.couplesRibRum[0].informationPrelevement.rib!.codeSage = '55555';
      component.formGroupRib.get('ribPrefixe')?.setValue('prefixe');
      component.formGroupRib.get('ribNumCompte')?.setValue('numCompte');

      jest.spyOn(modalRefSpy, 'afterClosed').mockReturnValue(of(false));

      component.onRIBSaveClick(component.couplesRibRum[0]);
      tick();
      expect(clientServiceSpy.updateInformationPrelevement).not.toHaveBeenCalled();
    }));
  ```

## Résultat

Depuis cette correction, **la liste des RIB/RUM ne se recharge plus pour rien**.  
Ça allège les appels serveurs, fluidifie l’expérience utilisateur, et surtout évite des effets visuels inutiles.  

<video controls width="100%">
  <source src="/videos/ml_15287.mp4" type="video/mp4"/>
  Votre navigateur ne supporte pas la vidéo HTML5.
</video>


---
