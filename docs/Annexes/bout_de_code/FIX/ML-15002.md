---
sidebar_label: "ML-15002 – Code source"
sidebar_position: 2
tags:
  - Bug
  - Comptabilité
  - Pièces comptables
  - Recherche
  - Code
---

# Code source

## recherche-piece-comptables.component.ts

```ts

import {Component, DestroyRef, ElementRef, OnInit, ViewChild} from '@angular/core';
import {ApporteurService} from '../../core/service/current-user/apporteur/apporteur.service';
import {
  ApporteurPaginate,
  Loueur,
  SensFactureDomain,
  SousTypeFactureDomain,
  StatutTransfertDomain,
  TypeFactureDomain,
  UserApporteurDomain,
} from '@leasa/rest-api-angular';
import {TYPE_TIERS, typeTiers} from '@models/constant/typeTiers';
import {FormArray} from '@angular/forms';
import {RecherchePieceComptableFormGroup} from './recherche-piece-comptable-form-group';
import {ORIGINE, origine} from '../../models/constant/origine';
import {FactureService} from '../../core/service/facture/facture.service';
import {BehaviorSubject, Subject} from 'rxjs';
import {BailleurService} from '../../core/service/bailleur/bailleur.service';
import {GroupeApporteursService} from '../../core/service/groupe-apporteurs/groupe-apporteurs.service';
import {PieceComptableDataSource} from '../piece-comptable.datasource';
import {CriteriaDatasource, PaginatorComponent} from '@leasa/ui';
import {Tiers, TiersPaginate} from '../../tiers/tiers';
import {ClientService} from '../../client/service/client.service';
import {ProtectionServiceProviderService} from '../../core/service/protection-service-provider/protection-service-provider.service';
import {SortUtils} from '../../core/utils/sort.utils';
import {LoueurService} from '../../shared/service/loueur/loueur.service';
import {MODE_PAIEMENT} from '../../models/constant/modePaiement';
import {SpecificiteLoueurService} from '../../core/service/loueur/specificites/specificite-loueur.service';
import {SPECIFICITE_LOUEUR} from '../../models/constant/specificiteLoueur';
import {CurrencyUtils} from '../../core/utils/currency.utils';
import {PAGINATE_DATASOURCE_PROPERTY} from '../../core/utils/paginate-datasource-property';
import {ApporteurDomain} from '@leasa/rest-api-angular/model/apporteurDomain';
import {CONVERTER_NAME} from '@models/constant/exportExcel';
import {DocumentService} from '../../shared/service/document/document.service';
import {takeUntilDestroyed} from '@angular/core/rxjs-interop';

@Component({
  selector: 'ml-recherche-piece-comptable',
  templateUrl: './recherche-piece-comptable.component.html',
  styleUrls: ['./recherche-piece-comptable.component.scss'],
})
export class RecherchePieceComptableComponent implements OnInit {
  @ViewChild('paginator') paginator: PaginatorComponent;
  public searchLoading: boolean = false;
  public isPrelevement: boolean = false;
  public criteriaLoading: boolean = false;
  public partenairesDemandeLoading: boolean = false;
  public pieceComptableDataSource: PieceComptableDataSource;
  public apporteurList: UserApporteurDomain[] = [];
  public numberPage: number;
  public columns = [
    'sens',
    'numeroInterne',
    'numeroComptable',
    'typePiece',
    'sousTypePiece',
    'emetteur',
    'destinataire',
    'montantHT',
    'montantTTC',
    'numeroDemandeLiee',
    'partenaireDemandeLiee',
    'dateCreation',
    'dateFacturation',
    'statut',
  ];
  public roleTiers: typeTiers[];
  public origines: origine[] = [ORIGINE.FACTURATION_DIVERSE, ORIGINE.MANUELLE, ORIGINE.SYSTEME, ORIGINE.WEB_SERVICE];
  public statuts: StatutTransfertDomain[];
  public formGroupPieceComptableCriteria: ReturnType<typeof RecherchePieceComptableFormGroup.build>;
  public datasourceClient: CriteriaDatasource<any>;
  public numberTotalElement: number;
  public sensList: SensFactureDomain[];
  public loueurList: Loueur[];
  private loueurSelected?: Loueur | null = null;
  public typeList: TypeFactureDomain[];
  public tiersList: TiersPaginate = {
    list: [],
    offset: 0,
    total: 0,
  };
  public partenairesDemandePaginate: ApporteurPaginate = {
    list: [],
    offset: 0,
    total: 0,
  };
  public sousTypeList: SousTypeFactureDomain[];
  public criteriaClient = this.updateCriteriaClient('');
  private criteriaChange = new BehaviorSubject<any>(this.criteriaClient);
  protected readonly String = String;
  protected readonly MODE_PAIEMENT = MODE_PAIEMENT;
  protected readonly TYPE_TIERS = TYPE_TIERS;
  protected formGroupLoading: boolean = true;
  protected showSearchResult: boolean = false;
  private anchorResults: ElementRef;
  private specificiteLoueursMap: Map<string, string> = new Map<string, string>();
  /**
   * Permet d'éviter l'effet de bord dû à la DOM (true si clique sur le bouton 'rechercher' false sinon)
   * @private
   */
  private shouldScroll: boolean = false;

  constructor(
    private apporteurService: ApporteurService,
    private factureService: FactureService,
    private bailleurService: BailleurService,
    private clientService: ClientService,
    private groupeApporteurService: GroupeApporteursService,
    private serviceProtectionService: ProtectionServiceProviderService,
    private loueurService: LoueurService,
    private specificiteLoueurService: SpecificiteLoueurService,
    private documentService: DocumentService,
    private destroyRef: DestroyRef,
  ) {}

  //Modification dynamique via setter personnalisé sur l'élément DOM anchorResults (pas de lien vers la doc mais fonctionne)
  @ViewChild('anchorResults') set anchorResultsContent(anchorResultsContent: ElementRef) {
    if (anchorResultsContent && this.shouldScroll) {
      this.anchorResults = anchorResultsContent;
      this.scrollToResults();
      this.shouldScroll = false;
    }
  }

  /**
   * affiche les statuts des factures dans le formulaire
   */
  get statutsFacture(): FormArray {
    return this.formGroupPieceComptableCriteria.get('codesStatutFacture') as FormArray;
  }

  /**
   * Initialise les dataSource,statuts, sens et types lors de l'initialisation du component
   */
  ngOnInit(): void {
    this.initDataSource();
    this.initStatutsFacture();
    this.initSensFacture();
    this.initTypeFacture();
    this.initLoueursFacture();
    this.initRoleTiersBySpecificiteLoueur();
    this.initPartenaireDemandeList();

    this.datasourceClient = new CriteriaDatasource(
      this.clientService.searchClient as any,
      this.criteriaChange,
      10,
      PAGINATE_DATASOURCE_PROPERTY,
    );
  }

  criteriaFilter(criteria: string) {
    if (this.formGroupPieceComptableCriteria.value.codeTypeEntiteFacture === TYPE_TIERS.CLIENT.code) {
      this.criteriaChange.next(this.updateCriteriaClient(criteria));
    }
  }

  /**
   * Réinitialise le formulaire et retire l'affichage des résultats
   */
  reinit() {
    this.formGroupPieceComptableCriteria.reset();
    this.pieceComptableDataSource.reinit();
    this.showSearchResult = false;
    this.isPrelevement = false;
  }

  /**
   * Appelle la fonction de recherche de facture
   */
  search() {
    this.searchPage(0);
    this.showSearchResult = true;
    this.shouldScroll = true;
  }

  /**
   * Ouvre une nouvelle page pour le téléchargement de l'export Excel de la recherche actuelle
   */
  exportExcel() {
    window.open(
      this.documentService.getResourceUrl(
        'factures/export/excel',
        Object.assign(this.mapToValidCriterias(this.formGroupPieceComptableCriteria.value), {
          excelConverterName: CONVERTER_NAME.RECHERCHE_PIECES_COMPTABLES,
        }),
      ),
    );
  }

  /**
   * Cherche et affiche les factures en fonction des critères du formulaire
   * @param index
   */
  searchPage(index: number) {
    const criteria = this.mapToValidCriterias(this.formGroupPieceComptableCriteria.value);
    this.pieceComptableDataSource.searchFacture(criteria, index);
  }

  private mapToValidCriterias(sourceCriteria: any): any {
    const validCriteria = Object.assign({}, sourceCriteria);
    if (validCriteria.codeDemande) {
      // Supprime tous les caractères blancs (espace, tabulation, saut de ligne...)
      validCriteria.codeDemande = validCriteria.codeDemande.replace(/\s+/g, '');
      validCriteria.codeDemande = validCriteria.codeDemande.split(';');
    }
    return validCriteria;
  }

  /**
   * Scroll jusqu'a l'ancre située au niveau du tableau de résultats
   */
  scrollToResults() {
    this.anchorResults.nativeElement.scrollIntoView({
      behavior: 'smooth',
      block: 'start',
    });
  }

  /**
   * Permet de cocher les statuts que l'on souhaite pour chercher une facture
   * @param index
   */
  statutsFactureChange(index: number) {
    if (this.statutsFacture.at(index).value === null) {
      this.statutsFacture.at(index).setValue(this.statuts[index].code);
    } else {
      this.statutsFacture.at(index).setValue(null);
    }
  }

  modePaiementChange(): void {
    this.formGroupPieceComptableCriteria.get('datePrelevementDebut')!.reset();
    this.formGroupPieceComptableCriteria.get('datePrelevementFin')!.reset();
    if (
      this.formGroupPieceComptableCriteria.value.modePaiement!.some(
        (modePaiement: string) => modePaiement === MODE_PAIEMENT.PRELEVEMENT.code,
      )
    ) {
      this.isPrelevement = true;
    } else {
      this.isPrelevement = false;
    }
  }

  /**
   * Controlle si le select Sens change, a chaque changement il reset les select de typeFacture et de sousTypeFacture et appelle la fonction initSousTypeByTypeAndSensFacture
   * @param codeSensFacture
   */
  sensFactureChange(codeSensFacture: string): void {
    this.initTypeFactureBySensFacture(codeSensFacture);
    this.formGroupPieceComptableCriteria.get('codeTypeFacture')!.reset();
    this.formGroupPieceComptableCriteria.get('codeSousTypeFacture')!.reset();
    this.initSousTypeByTypeAndSensFacture(codeSensFacture, this.formGroupPieceComptableCriteria.value.codeTypeFacture!);
  }

  /**
   * Controlle si le select Type change, a chaque changement il reste le select de sousTypeFacture et appelle la fonction initSousTypeByTypeAndSensFacture
   * @param codeTypeFacture
   */
  typeFactureChange(codeTypeFacture: string): void {
    this.formGroupPieceComptableCriteria.get('codeSousTypeFacture')!.reset();
    this.initSousTypeByTypeAndSensFacture(this.formGroupPieceComptableCriteria.value.sensFacture!, codeTypeFacture);
  }

  /**
   * Contrôle si le select Tiers change, a chaque changement il reset le select de typeTiers et appelle la fonction initTiersByRoleTiersFacture
   * @param codeRoleTiersFacture
   */
  tiersRoleChange(codeRoleTiersFacture: string): void {
    this.formGroupPieceComptableCriteria.get('idReferenceEntiteFacture')!.reset();
    this.initTiersByRoleTiersFacture(codeRoleTiersFacture);
  }

  loueurChange(codeLoueur: string) {
    this.formGroupPieceComptableCriteria.get('codeTypeEntiteFacture')!.reset();
    this.formGroupPieceComptableCriteria.get('idReferenceEntiteFacture')!.reset();
    this.formGroupPieceComptableCriteria.get('idPartenaireDemande')!.reset();
    this.loueurSelected = null;
    if (codeLoueur) {
      this.loueurSelected = this.loueurList.find((loueur) => loueur.code === codeLoueur);
      this.initRoleTiersBySpecificiteLoueur(codeLoueur);
    } else {
      this.roleTiers = SortUtils.sortAlphabeticallyAsc<typeTiers>(
        [
          TYPE_TIERS.APPORTEUR,
          TYPE_TIERS.BAILLEUR,
          TYPE_TIERS.CLIENT,
          TYPE_TIERS.GROUPE_APPORTEURS,
          TYPE_TIERS.SERVICE_PROTECTION,
        ],
        'libelle',
      );
    }
    this.initTiersByRoleTiersFacture(this.formGroupPieceComptableCriteria.value.codeTypeEntiteFacture!);
    this.initPartenaireDemandeList(codeLoueur);
  }

  private initDataSource(): void {
    this.pieceComptableDataSource = new PieceComptableDataSource(this.factureService);
    this.pieceComptableDataSource.numberPage$
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => (this.numberPage = value));
    this.pieceComptableDataSource.numberTotalElement$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((value) => {
      this.numberTotalElement = value;
      if (!this.showSearchResult) {
        this.showSearchResult = this.numberTotalElement >= 0;
      }
    });
    this.pieceComptableDataSource.loading$
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => (this.searchLoading = value));
  }

  /**
   * Charge et affiche les Tiers en fonction du type du tiers
   * @param codeRoleTiersFacture
   * @private
   */
  private initTiersByRoleTiersFacture(codeRoleTiersFacture: string) {
    let criteriaLoueur = {
      idLoueur: this.loueurSelected?.id,
      codeLoueur: this.loueurSelected?.code,
    };
    this.criteriaLoading = true;
    switch (codeRoleTiersFacture) {
      case TYPE_TIERS.APPORTEUR.code:
        this.apporteurService
          .searchByCriteria(Object.assign({paginate: false, orderBy: 'nom', desc: false}, criteriaLoueur))
          .pipe(takeUntilDestroyed(this.destroyRef))
          .subscribe((apporteurs) => {
            this.tiersList = apporteurs as TiersPaginate;
            this.criteriaLoading = false;
          });
        break;
      case TYPE_TIERS.BAILLEUR.code:
        this.bailleurService
          .searchByCriteria(Object.assign({paginate: false, orderBy: 'nom', desc: false}, criteriaLoueur))
          .pipe(takeUntilDestroyed(this.destroyRef))
          .subscribe((tiersByRoleTiers) => {
            this.tiersList = tiersByRoleTiers as TiersPaginate;
            this.criteriaLoading = false;
          });
        break;
      case TYPE_TIERS.CLIENT.code:
        this.criteriaLoading = false;
        break;
      case TYPE_TIERS.GROUPE_APPORTEURS.code:
        this.groupeApporteurService
          .searchByCriteria(Object.assign({paginate: false}, criteriaLoueur))
          .pipe(takeUntilDestroyed(this.destroyRef))
          .subscribe((groupeApporteurList) => {
            this.tiersList = {
              list: groupeApporteurList as Tiers[],
            } as TiersPaginate;
            this.criteriaLoading = false;
          });
        break;
      case TYPE_TIERS.SERVICE_PROTECTION.code:
        this.serviceProtectionService
          .searchByCriteria(Object.assign({paginate: false}, criteriaLoueur))
          .pipe(takeUntilDestroyed(this.destroyRef))
          .subscribe((protectionServiceProviderList) => {
            this.tiersList = protectionServiceProviderList as TiersPaginate;
            this.criteriaLoading = false;
          });
        break;
      case null:
        this.tiersList = {list: [] as Tiers[]} as TiersPaginate;
        this.criteriaLoading = false;
        break;
      default:
        console.log("Le type tiers n'existe pas");
        break;
    }
  }

  /**
   * Récupère la valeur internationale de la devise en fonction de la devise Leasa
   * @param devise
   */
  getCurrency(devise: string) {
    return CurrencyUtils.parseToAngularDevise(devise);
  }

  /**
   * Fonction de filtrage des apporteurs par loueur (pour les optgroups)
   * @param listApporteurs La liste des ApporteurDomain
   * @param loueur Le Loueur sur lequel filtrer
   */
  apporteursOfLoueur(listApporteurs: ApporteurDomain[], loueur: Loueur) {
    return listApporteurs.filter((apporteur) => apporteur.loueur.code == loueur.code);
  }

  /**
   * Fonction de filtrage des loueurs par le loueur sélectionné dans le filtre "Loueur" (pour les optgroups)
   */
  loueurPartenaireList() {
    return this.loueurList.filter((loueur) => !this.loueurSelected || loueur.code == this.loueurSelected.code);
  }

  /**
   * Charge et affiche les types en fonction du sens de la facture
   * @param codeSensFacture
   * @private
   */
  private initTypeFactureBySensFacture(codeSensFacture: string) {
    if (codeSensFacture) {
      this.factureService
        .getTypeFactureBySensFacture(codeSensFacture)
        .pipe(takeUntilDestroyed(this.destroyRef))
        .subscribe((typeBySensFacture) => {
          this.typeList = typeBySensFacture;
        });
    }
  }

  /**
   * Charge et affiche les sous types en fonction du type et du sens de la facture
   * @param codeSensFacture
   * @param codeTypeFacture
   * @private
   */
  private initSousTypeByTypeAndSensFacture(codeSensFacture: string, codeTypeFacture: string) {
    if (codeSensFacture && codeTypeFacture) {
      this.factureService
        .getSousTypeFacturebyTypeAndSensFacture(codeTypeFacture, codeSensFacture)
        .pipe(takeUntilDestroyed(this.destroyRef))
        .subscribe((sousTypeByTypeBySensFacture) => {
          this.sousTypeList = SortUtils.sortAlphabeticallyAsc(sousTypeByTypeBySensFacture, 'libelle');
        });
    }
  }

  /**
   * Charge et affiche les types de facture
   * @private
   */
  private initTypeFacture(): void {
    this.factureService
      .getTypeFacture()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((typeFacture) => {
        this.typeList = typeFacture;
      });
  }

  private initLoueursFacture(): void {
    this.loueurList = this.loueurService.getLoueursSelected();
  }

  /**
   * Charge et affiche les sens de facture
   * @private
   */
  private initSensFacture(): void {
    this.factureService
      .getSensFacture()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((sensFacture) => {
        this.sensList = sensFacture;
      });
  }

  /**
   * Charge et affiche les statuts de facture
   * @private
   */
  private initStatutsFacture(): void {
    this.factureService
      .getStatutsFacture()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((statutsFacture) => {
        this.statuts = statutsFacture;
        this.formGroupPieceComptableCriteria = RecherchePieceComptableFormGroup.build(this.statuts);
        this.formGroupLoading = false;
      });
  }

  private initRoleTiersBySpecificiteLoueur(codeLoueur?: string) {
    if (this.specificiteLoueursMap.size == 0) {
      this.loueurList.forEach((loueur) => {
        this.specificiteLoueurService
          .getSpecificiteByIdLoueurByCode(loueur.id, SPECIFICITE_LOUEUR.PROTECTION_SERVICE)
          .subscribe((specificiteLoueur) => {
            this.specificiteLoueursMap.set(loueur.code, specificiteLoueur.value);
            this.updateRoleTiers();
          });
      });
    } else {
      this.updateRoleTiers(codeLoueur);
    }
  }

  private updateRoleTiers(codeLoueur?: string): void {
    this.roleTiers = [TYPE_TIERS.APPORTEUR, TYPE_TIERS.BAILLEUR, TYPE_TIERS.GROUPE_APPORTEURS, TYPE_TIERS.CLIENT];
    if (codeLoueur) {
      if (this.specificiteLoueursMap.get(codeLoueur) == 'true') {
        this.roleTiers.push(TYPE_TIERS.SERVICE_PROTECTION);
      }
    } else {
      const hasTrueValue = Array.from(this.specificiteLoueursMap.values()).some((value) => value === 'true');
      if (hasTrueValue) {
        this.roleTiers.push(TYPE_TIERS.SERVICE_PROTECTION);
      }
    }
    this.roleTiers = SortUtils.sortAlphabeticallyAsc(this.roleTiers, 'libelle');
  }

  /**
   * Formate les critères de recherche pour la datasource de client
   * @param criteria la chaîne de caractère à insérer dans le critère
   * @private
   */
  private updateCriteriaClient(criteria: string) {
    return {raisonSocialeOrSecondNumeroIdentification: criteria, orderBy: 'raisonSociale'};
  }

  /**
   * Récupère la liste des apporteurs de l'utilisateur connecté (filtrage serveur)
   * @param codeLoueur Le code éventuel du loueur du filtre loueur du formulaire
   * @private
   */
  private initPartenaireDemandeList(codeLoueur?: string) {
    this.partenairesDemandeLoading = true;
    let criteria = {paginate: false, orderBy: 'nom', desc: false} as any;
    if (codeLoueur) {
      criteria.codeLoueur = codeLoueur;
    }
    this.apporteurService
      .searchByCriteria(criteria)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((apporteurs) => {
        this.partenairesDemandePaginate = apporteurs;
        this.partenairesDemandeLoading = false;
      });
  }
}
```
